
from ctypes import *
import ctypes
import os.path

import numpy as np

from yde.lib.misc.basics import ExportHelper
from yde.lib.inspect import fake_module
from yde.lib.ctypes_helper import FunctionDeclHelp, EnumMeta
from yde.lib.ctypes_pycp import parse_header, MakeCtype, SimplifyTypeDecl
from yde.lib.decorators import attribute_proxy

from .base import _type_aliases

_headers_path = os.path.abspath(os.path.join(os.path.dirname(__file__),'TDC_headers'))

_type_interp = MakeCtype(_type_aliases,stdc_types=True)

_header = """
# This file is autogenerated

import ctypes

from ..base import _handle_errors, tdclib
from ..base import *
"""


revmap = {
    getattr(ctypes,'c_'+n):'ctypes.c_'+n
    for n in 'char float double int8 int16 int32 int64 uint8 uint16 uint32 uint64'.split()
}
revmap.update({
    ctypes.POINTER(k):'ctypes.POINTER(%s)'%v
    for k,v in revmap.items()
})
def qualtname(type):
    if type is None: return 'None'
    ret = revmap.get(type,None)
    if ret is not None:
        return ret
    tname = type.__name__
    if tname.startswith('LP_'):
        tname = 'ctypes.POINTER('+qualtname(type._type_)+')'
    else:
        print(tname)
    return tname

@attribute_proxy
def mkwrap(fun):
    wrapped = 'tdclib.TDC_'+fun
    info = functions.pop('TDC_'+fun)
    restype = qualtname(info[0][1])
    argtypes = ', '.join(qualtname(t) for n,t in info[1:])
    def decl(args,body):
        body = '\n'.join(l for l in body.split('\n') if l.strip())
        return """
{wrapped}.restype = {restype}
{wrapped}.argtypes = [{argtypes}]
def {fun}({args}):
{body}
        """.format(
            wrapped=wrapped,
            restype=restype,
            argtypes=argtypes,
            fun=fun,
            args=args,
            body=body.format(
                wrapped='_handle_errors('+wrapped,
                pw=',%s,"%s",(%s))'%(wrapped,'TDC_'+fun,args),
            )
        )
    return decl

#######################################################
# tdcbase.h
#######################################################

tdcbase_h = os.path.join(_headers_path,'tdcbase')
types, statics, functions = parse_header(
    tdcbase_h+'.h',
    type_interpreter=_type_interp.visit,
)
print(types, statics, functions)

wrapper_src = _header

wrapper_src += mkwrap.setChannelDelays('delays',"""
    delays = np.array(delays,'i4')
    assert delays.shape==(8,)
    {wrapped}(delays.ctypes.data_as(ctypes.POINTER(ctypes.c_int32))){pw}
""")

wrapper_src += mkwrap.getDeviceParams('',"""
    channelMask = ctypes.c_int32()
    coincWin = ctypes.c_int32()
    expTime = ctypes.c_int32()
    {wrapped}(ctypes.byref(channelMask),ctypes.byref(coincWin),ctypes,byref(expTime)){pw}
    return channelMask.value, coincWin.value, expTime.value
""")

wrapper_src += mkwrap.getCoincCounters('',"""
    data = np.empty(COINC_CHANNELS,'i4')
    updates = ctypes.c_int32()
    {wrapped}(data.ctypes.data_as(ctypes.POINTER(ctypes.c_int32)),ctypes.byref(updates)){pw}
    return data, updates.value
""")

no_error_return = set("""
getVersion perror getTimebase getDevType checkFeatureHbt checkFeatureLifeTime
""".split())
for name,info in functions.items():
    assert name.startswith('TDC_')
    fun = name[4:]
    wrapped = 'tdclib.'+name
    restype = qualtname(info[0][1])
    argtypes = ', '.join(qualtname(t) for n,t in info[1:])
    args = ', '.join(n for n,t in info[1:])
    wrapper_src += """
{wrapped}.restype = {restype}
{wrapped}.argtypes = [{argtypes}]""".format(
        wrapped=wrapped,
        restype=restype,
        argtypes=argtypes,
    )
    if fun in no_error_return:
        wrapper_src += """
def {name}({args}):
    return {wrapped}({args})
        """.format(name=fun,wrapped=wrapped,args=args)
#        fun.restype = v[0][1]
    else:
        wrapper_src += """
def {name}({args}):
    _handle_errors({wrapped}({args}),{wrapped},"TDC_{name}",({args}))
        """.format(name=fun,wrapped=wrapped,args=args)
#        fun.restype = ErrorCode

with open(tdcbase_h+'.py','w') as fh:
    fh.write(wrapper_src)


#######################################################
# tdcstartstop.h
#######################################################


#########################################################################################################
# tdchbt.h
#########################################################################################################


tdchbt_h = os.path.join(_headers_path,'tdchbt')
types, statics, functions = parse_header(
    tdchbt_h+'.h',
    type_interpreter=_type_interp.visit,
)
print(types, statics, functions)

wrapper_src = _header

no_error_return = set("""
getHbtFitStartParams createHbtFunction releaseHbtFunction
""".split())
for name,info in functions.items():
    assert name.startswith('TDC_')
    fun = name[4:]
    wrapped = 'tdclib.'+name
    restype = qualtname(info[0][1])
    argtypes = ', '.join(qualtname(t) for n,t in info[1:])
    args = ', '.join(n for n,t in info[1:])
    wrapper_src += """
{wrapped}.restype = {restype}
{wrapped}.argtypes = [{argtypes}]""".format(
        wrapped=wrapped,
        restype=restype,
        argtypes=argtypes,
    )
    if fun in no_error_return:
        wrapper_src += """
def {name}({args}):
    return {wrapped}({args})
        """.format(name=fun,wrapped=wrapped,args=args)
#        fun.restype = v[0][1]
    else:
        wrapper_src += """
def {name}({args}):
    _handle_errors({wrapped}({args}),{wrapped},"TDC_{name}",({args}))
        """.format(name=fun,wrapped=wrapped,args=args)
#        fun.restype = ErrorCode

with open(tdchbt_h+'.py','w') as fh:
    fh.write(wrapper_src)

################################################################################################################################################
# tdclifetm.h
##########################################################################################################################################

